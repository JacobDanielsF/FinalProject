// ARTG/CMPM 120 Final Project
// Tomb of the Ancients
// DungeonGeneration.js
// Methods which handle dungeon generation

		// DUNGEON GENERATION
		// Dungeon generation methods, in the order that they are accessed: SpawnDungeon(), Shuffle(), MakeRoom(), MakePath(), MakeWalls(), InBounds()
		// SpawnDungeon() determines the general layout of a dungeon while applying significant randomization.
		// Shuffle() is a helper function that simply shuffles an array.
		// MakeRoom() stores room values generated by SpawnDungeon().
		// MakePath() calls MakeRoom() but shapes rooms in a hallway formation.
		// MakeWalls() actually builds the walls by placing sprites in the way we ask it to.
		// InBounds() is an important helper function that determines what kind of tile should be drawn.
		
		
		// MakeRoom()
		// stores all room values as subarrays in rooms[]. InBounds() will later check for these values.
		// anything that can be initialized in a certain type of room will check for roomtype and save
		// -the coordinates for where that entity should spawn, which can be accessed later.
		function MakeRoom(x, y, width, height, roomtype){
			rooms.push([x, y, width, height]);
			
			if (roomtype == "normal"){
				mainrooms.push([x, y, width, height]);
				
			}
	
			if (roomtype == "start") { // save player coordinates.
				playercoords = [x, y];
			}
	
			if (roomtype == "hall") { // chance of spawning an arbitrary enemy in a hallway segment.
				enemies.push([x, y]);
				
			}
			
			
	
			if (roomtype == "boss") { // save boss coordinates.
				bosscoords = [x, y];
				bossroom = [x, y, width, height];
			}
			
		}
		
		// MakePath()
		// creates 2 narrow rooms that connect (x1,y1) and (x2,y), resembling hallways.
		// pathtype determines which side the path will appear on, spawnenemy determines if an enemy can spawn inside it.
		function MakePath(x1, y1, x2, y2, pathtype, spawnenemy){
			var halltype = "hall";
			
			// bypass enemy spawning in hallway directly adjacent from spawn
			
			var avgX = (x1+x2)/2;
			var diffX = game.math.difference(x1, x2);
			
			// spawn first hallway segment (in one of two directions)
			if (pathtype == "in") {
				if (spawnenemy == false) {
					halltype = "cleanhall";
				}
				MakeRoom(avgX, y1, (diffX) + PATH_WIDTH, PATH_WIDTH, halltype);
			} else if (pathtype == "out") {
				MakeRoom(avgX, y2, (diffX) + PATH_WIDTH, PATH_WIDTH, halltype)
			}
			
			var halltype = "hall";
	
			var avgY = (y1+y2)/2;
			var diffY = game.math.difference(y1, y2);
			
			// spawn second hallway segment (in one of two directions)
			if (pathtype == "in") {
				MakeRoom(x2, avgY, PATH_WIDTH, (diffY) + PATH_WIDTH, halltype);
			} else if (pathtype == "out") {
				if (spawnenemy == false) {
					halltype = "cleanhall";
				}
				MakeRoom(x1, avgY, PATH_WIDTH, (diffY) + PATH_WIDTH, halltype);
			}
		}
		
		// InBounds()
		// checks if the (x,y) pair exists in a room, a wall, or a ledge and returns a status.
		function InBounds(x,y){
			var tilestatus = "wall";
			var OOBcount = 0;
			for (var i = 0; i < rooms.length; i++) { // check the bounds of all rooms
				var boundX1 = rooms[i][0] - (rooms[i][2]/2);
				var boundX2 = rooms[i][0] + (rooms[i][2]/2);
				var boundY1 = rooms[i][1] - (rooms[i][3]/2);
				var boundY2 = rooms[i][1] + (rooms[i][3]/2);
				var extrabound = boundY1 - WALL_SIZE; // designate a small space above a room where a ledge can be placed
				
				if ((x <= boundX1 - (WALL_SIZE*2)) || (x > boundX2 + (WALL_SIZE*2)) || (y <= boundY1 - (WALL_SIZE*2)) || (y > boundY2 + (WALL_SIZE*2))){
					OOBcount++;
				}
				
				if (x > boundX1 && x <= boundX2) {
					if (y > extrabound && y <= boundY1 && tilestatus != "air") {
						tilestatus = "ledge";
					}
					if (y > boundY1 && y <= boundY2) {
						tilestatus = "air";
					}
				}
			}
			
			// out of bounds
			if (OOBcount == rooms.length){
				tilestatus = "OOB";
			}
			
			return tilestatus;
		}
		
		// MakeWalls()
		// places tiles across the map space. essentially a grid full of squares carved out by checking InBounds().
		// the status returned by InBounds() indicates what kind of sprite should be placed.
		function MakeWalls(){
			for (var i = WALL_SIZE/2; i <= FLOOR_SIZE-(WALL_SIZE/2); i += WALL_SIZE) {
				for (var j = WALL_SIZE/2; j <= FLOOR_SIZE-(WALL_SIZE/2); j += WALL_SIZE) {
					var tilestatus = InBounds(i,j);
					
					// tile sprites by: asalga (Andor Salga) and gtkampos from opengameart.org
					
					if (tilestatus == "wall") {
						var tile = walls.create(i, j, 'tile_atlas', 'wall'); // spawn a wall
						tile.body.immovable = true;
						tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
						tile.anchor.x = 0.5;
						tile.anchor.y = 0.5;
					} else if (tilestatus == "ledge") {
						var tile = walls.create(i, j, 'tile_atlas', 'ledge'); // spawn a ledge
						tile.body.immovable = true;
						tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
						tile.anchor.x = 0.5;
						tile.anchor.y = 0.5;
					} else if (tilestatus == "air")  { // if status == "air"
						var tile = game.add.sprite(i, j, 'tile_atlas', 'floor1'); // spawn a floor tile
						tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
						tile.anchor.x = 0.5;
						tile.anchor.y = 0.5;
						
						var rand = game.rnd.integerInRange(0, 12);
						if (rand == 0) {
							var overlay = game.add.sprite(i, j, 'tile_overlay', 'glyph1'); // spawn glyph
							overlay.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
							overlay.anchor.x = 0.5;
							overlay.anchor.y = 0.5;
						} else if (rand == 1) {
							var overlay = game.add.sprite(i, j, 'tile_overlay', 'glyph2'); // spawn glyph
							overlay.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
							overlay.anchor.x = 0.5;
							overlay.anchor.y = 0.5;
						} else if (rand == 2) {
							var overlay = game.add.sprite(i, j, 'tile_overlay', 'glyph3'); // spawn glyph
							overlay.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
							overlay.anchor.x = 0.5;
							overlay.anchor.y = 0.5;
						} else if (rand == 3) {
							var overlay = game.add.sprite(i, j, 'tile_overlay', 'glyph4'); // spawn glyph
							overlay.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
							overlay.anchor.x = 0.5;
							overlay.anchor.y = 0.5;
						}
						
						
					} else if (tilestatus == "OOB") {
						var tile = game.add.sprite(i, j, 'tile_atlas', 'wall'); // spawn a wall
						tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
						tile.anchor.x = 0.5;
						tile.anchor.y = 0.5;
					}
					
				}
			}
		}
		
		// Shuffle()
		// shuffles elements of an array.
		function Shuffle(t){
			var n = t.length-1;
			while (n >= 0) {
				var k = game.rnd.integerInRange(0, n);
				var temp = t[n];
				t[n] = t[k];
				t[k] = temp;
				n--;
			}
			return t;
		}
		
		// SpawnDungeon()
		// determines the general layout of the dungeon and spawns rooms and paths with SpawnRoom() and SpawnPath().
		// room positions are determined by shuffling arrays of X and Y vertices using Shuffle()
		// room information is stored in points[i], which can be referred to as the centerpoints of rooms or the
		// -endpoints of paths. both are drawn out using the same set of points, with a bit of randomness varience.
		function SpawnDungeon(){
			var pointnum = game.rnd.integerInRange(6, 8);
			var groupx = [];
			var groupy = [];
			
			// initialize default point values
			for (var i = 0; i < pointnum; i++) {
				groupx[i] = i;
				groupy[i] = i;
			}
			
			// shuffle point values
			groupx = Shuffle(groupx);
			groupy = Shuffle(groupy);

			// store room values in points[]
			for (var i = 0; i < pointnum; i++) {
				var pointX = (FLOOR_SIZE*((groupx[i]+1)/(pointnum+1))) + game.rnd.integerInRange(-WALL_SIZE/4, WALL_SIZE/4);
				var pointY = (FLOOR_SIZE*((groupy[i]+1)/(pointnum+1))) + game.rnd.integerInRange(-WALL_SIZE/4, WALL_SIZE/4);
				points[i] = [pointX, pointY];
			}
			
			// spawn rooms 1 to i-1. the last room is special, so it is added outside of the loop.
			for (var i = 0; i < pointnum-1; i++) {
				// spawn room.
				if (i == 0) {
					MakeRoom(points[i][0], points[i][1], START_ROOM*WALL_SIZE, START_ROOM*WALL_SIZE, "start");
				} else {
					MakeRoom(points[i][0], points[i][1], game.rnd.integerInRange(ROOM_MIN*WALL_SIZE, ROOM_MAX*WALL_SIZE), game.rnd.integerInRange(ROOM_MIN*WALL_SIZE, ROOM_MAX*WALL_SIZE), "normal");
				}
				
				// prevent enemy spawning in the first path that is always adjacent to the spawn.
				var makeenemy = true;
				if (i == 0) {
					makeenemy = false;
				}
				
				// spawn a path that goes from the current room to the next one.
				var temp = game.rnd.integerInRange(0, 1);
				if (temp == 0) {
					MakePath(points[i][0], points[i][1], points[i+1][0], points[i+1][1], "in", makeenemy);
				} else {
					MakePath(points[i][0], points[i][1], points[i+1][0], points[i+1][1], "out", makeenemy);
				}
			}
			
			// spawn the boss room (this is special because no path needs to continue from it, and it spawns a boss.)
			MakeRoom(points[pointnum-1][0], points[pointnum-1][1], BOSS_ROOM*WALL_SIZE, BOSS_ROOM*WALL_SIZE, "boss");
			
			// draw the physical wall sprites.
			MakeWalls();
		}
		
//SpawnDungeon.prototype = Object.create();
SpawnDungeon.prototype.constructor = SpawnDungeon;






		function PlayerInBounds(x,y){
			for (var i = 0; i < mainrooms.length; i++) { // check the bounds of all rooms
				var skip = false;
				for (var j = 0; j < completedrooms.length; j++){
					if (i == completedrooms[j]) {
						skip = true;
					}
				}
				if (skip == false){
					var boundX1 = mainrooms[i][0] - (mainrooms[i][2]/2);
					var boundX2 = mainrooms[i][0] + (mainrooms[i][2]/2);
					var boundY1 = mainrooms[i][1] - (mainrooms[i][3]/2);
					var boundY2 = mainrooms[i][1] + (mainrooms[i][3]/2);
					
					if (x > boundX1 - (boundX1 % WALL_SIZE) + (WALL_SIZE/2) && x <= boundX2 - (boundX2 % WALL_SIZE) - (WALL_SIZE/2)) {
						if (y > boundY1 - (boundY1 % WALL_SIZE) + (WALL_SIZE/2) && y <= boundY2 - (boundY2 % WALL_SIZE) - (WALL_SIZE/2)) {
							return i;
						}
					}
				}
			}
			return -1;
		}
		
		function PlayerInBoss(x,y){
			var boundX1 = bossroom[0] - (bossroom[2]/2);
			var boundX2 = bossroom[0] + (bossroom[2]/2);
			var boundY1 = bossroom[1] - (bossroom[3]/2);
			var boundY2 = bossroom[1] + (bossroom[3]/2);
				
			if (x > boundX1 - (boundX1 % WALL_SIZE) + (WALL_SIZE/2) && x <= boundX2 - (boundX2 % WALL_SIZE) - (WALL_SIZE/2)) {
				if (y > boundY1 - (boundY1 % WALL_SIZE) + (WALL_SIZE/2) && y <= boundY2 - (boundY2 % WALL_SIZE) - (WALL_SIZE/2)) {
					return true;
				}
			}
			return false;
		}
		
		//console.log(player.body.x + ", " + player.body.y);
		
		function MakeBounds(num){
			var roombounds = mainrooms[num];
			var boundX1 = roombounds[0] - (roombounds[2]/2);
			var boundX2 = roombounds[0] + (roombounds[2]/2);
			var boundY1 = roombounds[1] - (roombounds[3]/2);
			var boundY2 = roombounds[1] + (roombounds[3]/2);
			
			// create upper wall
			for (var i = boundX1 - (WALL_SIZE/2); i <= boundX2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = i;
				var tileY = boundY1 - (WALL_SIZE/2);
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'ledge'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
			// create lower wall
			for (var i = boundX1 - (WALL_SIZE/2); i <= boundX2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = i;
				var tileY = boundY2 + (WALL_SIZE/2);
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'wall'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
			// create left wall
			for (var i = boundY1 - (WALL_SIZE/2); i <= boundY2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = boundX1 - (WALL_SIZE/2);
				var tileY = i;
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'wall'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
			// create right wall
			for (var i = boundY1 - (WALL_SIZE/2); i <= boundY2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = boundX2 + (WALL_SIZE/2);
				var tileY = i;
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'wall'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
		}
		
		
		function MakeBossBounds(){
			var boundX1 = bossroom[0] - (bossroom[2]/2);
			var boundX2 = bossroom[0] + (bossroom[2]/2);
			var boundY1 = bossroom[1] - (bossroom[3]/2);
			var boundY2 = bossroom[1] + (bossroom[3]/2);
			
			// create upper wall
			for (var i = boundX1 - (WALL_SIZE/2); i <= boundX2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = i;
				var tileY = boundY1 - (WALL_SIZE/2);
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'ledge'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
			// create lower wall
			for (var i = boundX1 - (WALL_SIZE/2); i <= boundX2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = i;
				var tileY = boundY2 + (WALL_SIZE/2);
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'wall'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
			// create left wall
			for (var i = boundY1 - (WALL_SIZE/2); i <= boundY2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = boundX1 - (WALL_SIZE/2);
				var tileY = i;
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'wall'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
			// create right wall
			for (var i = boundY1 - (WALL_SIZE/2); i <= boundY2 + (WALL_SIZE/2); i += WALL_SIZE){
				var tileX = boundX2 + (WALL_SIZE/2);
				var tileY = i;
				var tile = currentwalls.create(tileX - (tileX % WALL_SIZE) + (WALL_SIZE/2), tileY - (tileY % WALL_SIZE) + (WALL_SIZE/2), 'tile_atlas', 'wall'); // spawn a wall
				
				tile.body.immovable = true;
				tile.scale.setTo(WALL_SIZE/64, WALL_SIZE/64);
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.5;
			}
		}